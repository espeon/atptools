/* eslint-disable */
// This file is automatically generated, do not edit!

/**
 * @module
 * Lexicons used internally in atp.tools
 */

import "@atcute/client/lexicons";

declare module "@atcute/client/lexicons" {
  namespace ToolsAtpTypingTest {
    interface Record {
      $type: "tools.atp.typing.test";
      /**
       * Accuracy of the typing test, percentage. Formula: (correctKeystrokes / totalKeystrokes) * 100 \
       * Minimum: 0 \
       * Maximum: 100
       */
      accuracy: number;
      /** Mode of the typing test */
      mode: Brand.Union<QuoteMode | TextMode | TimerMode>;
      /** Ratio of total correct:total:fixed keystrokes. */
      ratio: string;
      /**
       * Raw words per minute detected by the application. Formula: (totalKeystrokes / 5) * (60 / timeElapsed) \
       * Minimum: 0 \
       * Maximum: 10000
       */
      rawWpm: number;
      /** Text prompted for the typing test. */
      textPrompted: Brand.Union<
        PromptedTextClosed | PromptedTextOpen | PromptedTextWithSource
      >;
      /**
       * Time taken to complete the typing test in milliseconds \
       * Minimum: 0
       */
      timeMs: number;
      /**
       * Words per minute detected by the application. Formula: (correctKeystrokes / 5) * (60 / timeElapsed) \
       * Minimum: 0 \
       * Maximum: 10000
       */
      wpm: number;
      /**
       * Consistency of the typing test, percentage. Formula not currently available. \
       * Minimum: 0 \
       * Maximum: 100
       */
      consistency?: number;
      /** Minimum array length: 1 */
      dataPoints?: DataPoint[];
    }
    interface DataPoint {
      [Brand.Type]?: "tools.atp.typing.test#dataPoint";
      /**
       * Number of errors \
       * Minimum: 0
       */
      errors: number;
      /**
       * Time in milliseconds \
       * Minimum: 0
       */
      time: number;
      /**
       * Words per minute \
       * Minimum: 0
       */
      wpm: number;
      /**
       * Raw words per minute \
       * Minimum: 0
       */
      rawWpm?: number;
    }
    interface PromptedTextClosed {
      [Brand.Type]?: "tools.atp.typing.test#promptedTextClosed";
      /** Text to be typed */
      text: string;
    }
    interface PromptedTextOpen {
      [Brand.Type]?: "tools.atp.typing.test#promptedTextOpen";
      /**
       * Number of characters typed \
       * Minimum: 0
       */
      charsTyped: number;
      /** Text to be typed */
      text: string;
    }
    interface PromptedTextWithSource {
      [Brand.Type]?: "tools.atp.typing.test#promptedTextWithSource";
      /** Source of the text */
      source: string;
      /** Text to be typed */
      text: string;
    }
    interface QuoteMode {
      [Brand.Type]?: "tools.atp.typing.test#quoteMode";
      /** Type of the typing test mode */
      mode: string;
      /** The sub-mode setting of the quote mode */
      subMode: "short" | "medium" | "long" | "xl";
    }
    /** Mode of the typing test */
    interface TextMode {
      [Brand.Type]?: "tools.atp.typing.test#textMode";
      /** Type of the typing test mode */
      mode: string;
      /** The sub-mode setting of the text mode */
      subMode: number;
    }
    interface TimerMode {
      [Brand.Type]?: "tools.atp.typing.test#timerMode";
      /** Type of the typing test mode */
      mode: string;
      /** The sub-mode setting of the timer mode */
      subMode: number;
    }
  }

  interface Records {
    "tools.atp.typing.test": ToolsAtpTypingTest.Record;
  }

  interface Queries {}

  interface Procedures {}
}
